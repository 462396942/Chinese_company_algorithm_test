#coding:utf-8
"""
三年二班的同学们要去郊游了，他们决定所有人都从一个地方出发，但是每个人都要有不同的路线，
最终完成一次郊游。所以他们想知道，
在它们去的公园里，究竟有多少种不同的路线供选择。
公园可以被描述为一个具有N个结点，M条有向边的图，你要做的任务就是，选择其中某个点，
使得其能够产生尽量多的从这个点出发的路线。
提示：此处可以利用node代表结点的总数，结点编号从0到node-1。edge用来描述边。你
的程序应该返回路径最多的结点对应的路径数。
注意：所有的边都是有向边！数据输入将保证不包含环路，不包括重复的边。

输入数据示例：
node = 4

edge = {{0, 1}, {1, 2}, {2, 3}, {0, 2}}，包含4条有向边

输出结果：5

示例解释：
显然，0号节点应该是起点。
对应的5条路线为：
0 1
0 1 2
0 1 2 3
0 2
0 2 3

输入:
输入描述
输入数据包含M+2行
第一行 整型 node的个数N，范围1-10000
第二行 描述边是M行2列矩阵大小，M  2
第三行-第M+2行表示edge的数据，其中每行代表一条有向边，实际上可以描述成一个N*2的二维数组，行描述边，列表示结点
输出:
输出描述
最大路径的数:一个整型数字
输入范例:
输入范例 例如下面表示总共4个结点和4条边：
4      (总共4个结点，编号0,1,2,3)
4 2
0 1 （从结点0到结点1的一条有向边）
1 2 （从结点1到结点2的一条有向边）
2 3 （从结点2到结点3的一条有向边）
0 2 （从结点0到结点2的一条有向边）
输出范例:
输出范例 例如：
5
思路：把邻接矩阵记录下来
0 [[0,1,0,0],
1  [0,0,1,0],
2  [0,0,0,1],
3  [0,0,0,0]]
第2个结点可以到达3,将第3个结点的行加到第2个结点行，
0 [[0,1,1,0],
1  [0,0,1,0],
2  [0,0,0,1],
3  [0,0,0,0]]
第1个结点可以到达1,将第1个结点的行加到第1个结点行，
0 [[0,1,1,0],
1  [0,0,1,1],
2  [0,0,0,1],
3  [0,0,0,0]]
第0个结点可以到达1和2,将第1个结点和第2个结点的行加到第0个结点行，
0 [[0,1,2,2],
1  [0,0,1,1],
2  [0,0,0,1],
3  [0,0,0,0]]
所以从0出发可以有最多的路线，且路线个数为5
存在一个问题：如何确定先从那个结点开始来叠加呢？
使用拓扑排序找到结点的顺序即可
代码可以使用字典进行优化！！！！！
"""
import copy
def getMaxPath(n, m, edges):
    matrix = [[0 for j in range(n)] for i in range(n)]
    for edge in edges:
        matrix[edge[0]][edge[1]] = 1
    
    # 获取topo排序
    mat = copy.deepcopy(matrix)
    topo = []
    nodes = [i for i in range(n)]
    while len(nodes) > 0:
        for i in nodes:
            if sum(mat[i]) == 0:
                topo.append(i)
                nodes.remove(i)
                for row in range(n):
                    mat[row][i] = 0
    
    # 根据topo排序叠加
    for row in topo:
        for col in range(n):
            if matrix[row][col] > 0:
                matrix[row] = list(map(lambda x,y:x+y, matrix[row], matrix[col]))
    
    print(max(sum(matrix[i]) for i in range(n)))


if __name__ == "__main__":
    n = int(input())
    m = int(input().split()[0])
    edges = []
    for i in range(m):
        edges.append([int(i) for i in input().split()])  
    getMaxPath(n, m, edges)       










